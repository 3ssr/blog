# Golang垃圾回收

> 所谓垃圾回收，即释放我们不再使用对象的内存

## 主要概念

- mutator：是指除了垃圾收集器之外的部分，比如说我们应用程序本身。其次就是根对象roots

- collector：垃圾收集器

- roots：golang的根对象就是协程栈上的指针对象

## 常见的垃圾回收策略

### 标记-清除法

思想大致如下：

1. 先从根对象进行扫描，当我们的根对象指向了某个堆上的对象，我们就认为这个对象是可达的
2. 可达对象指向的对象也是可达的
3. 从根对象开始遍历（广度遍历或深度遍历）

步骤：

1. 有触发垃圾回收的事件发生，一般是当申请堆内存的时候，做一个检测机制，或者定时回收 

2. STW（Stop The World），挂起整个程序，等待GC

3. 从根对象开始扫描，在堆上给每个可达的对象的header做一个`活跃标记`

4. 清除阶段，扫描整个堆，发现是活跃对象的话，则清除掉它的标志位即可。如果发现是非活跃对象即不可达对象，则把对象作为分小块，连接到被称为 `空闲链表` 的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。

5. 清除完成，继续程序

优缺点：

1. 思想简单，很好实现
2. 缺点是会容易产生要多的碎片，分配的时候速度较低，分配需要遍历空闲链表，最坏的情况是遍历到最后也没有找到合适的
