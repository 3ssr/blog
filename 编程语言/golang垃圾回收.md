# Golang垃圾回收

> 所谓垃圾回收，即释放我们不再使用对象的内存

## 主要概念

- mutator：是指除了垃圾收集器之外的部分，比如说我们应用程序本身。其次就是根对象roots

- collector：垃圾收集器

- roots：golang的根对象就是协程栈上的指针对象

## 常见的垃圾回收策略

### 标记-清除法

思想大致如下：

1. 先从根对象进行扫描，当我们的根对象指向了某个堆上的对象，我们就认为这个对象是可达的
2. 可达对象指向的对象也是可达的
3. 从根对象开始遍历（广度遍历或深度遍历）

步骤：

1. 有触发垃圾回收的事件发生，一般是当申请堆内存的时候，做一个检测机制，或者定时回收

2. STW（Stop The World），挂起整个程序，等待GC

3. 从根对象开始扫描，在堆上给每个可达的对象的header做一个`活跃标记`

4. 清除阶段，扫描整个堆，发现是活跃对象的话，则清除掉它的标志位即可。如果发现是非活跃对象即不可达对象，则把对象作为分小块，连接到被称为 `空闲链表` 的单向链表。在之后进行分配时只要遍历这个空闲链表，就可以找到分块了。

5. 清除完成，继续程序

优缺点：

1. 思想简单，很好实现
2. 缺点是会容易产生要多的碎片，分配的时候速度较低，分配需要遍历空闲链表，最坏的情况是遍历到最后也没有找到合适的
3. STW时间过长

### 引用计数法

思路：

1. 给每一个对象都分配一个计数器，代表有多少其他的对象引用我

2. 当没有对象再引用我的时候，就代表我是垃圾

步骤：

1. 当对象A刚被创建的时候，肯定有一个对象B指向自己，所以对象A的计数器为1

2. 当我们要更新一个指针的时候，原来引用对象的计数器-1，新引用对象的计数器+1

3. 当遇到某个计数器为0的对象A时，我们要把所有引用了A的对象的计数器-1，同样的道理，如果引用了A的对象-1后可能也为0，需要递归地更新计数器

优缺点：

1. 优点：不需要STW，回收过程分布在应用程序的运行中；垃圾会被立即回收
2. 缺点：需要开发人员手动回收，容易内存泄露；无法回收循环引用的对象；递归更新计数器可能会非常深

### 分代收集

思路：

把堆分配的对象，给他分代，这种算法基于这样的认知，大部分对象创建后很快就变成垃圾，其余的就是很长时间才会变成垃圾，那么我们没必要对这种长时间才变成垃圾的对象进行GC，浪费时间

1. 该算法把堆空间划分为四个部分，分别是生成空间，幸存空间1，幸存空间2，老年代空间。并且我们把前三者合并成为新生代空间。

2. 当对象刚创建的时候，分配的空间就是在生成空间。

3. 当生成空间满的时候，我们就对新生代空间进行GC，这里是是对整个新生代空间进行GC，采用的GC的算法就是节点复制。我们看图说话

4. 我们每次GC的时候，都会对对象的“年龄”加1，当判断对象的年龄到达一定阈值的时候，就把对象移动到老年代空间

5. 当我们对新生代对象进行GC的时候，是从新生代的根节点开始扫描，但是注意一有可能我们的老年代的对象也会指向新生代，所以如果我们把这点漏掉了，会多清除一些活跃的对象。为了解决这个问题，我们需要把老年代的对象扫描一遍，但是想想如果这样做的话我们岂不是每次要GC新生代对象的时候，都要把新、老都扫描了？

6. 用一个记录集来记录那些老年代的对象指向新生代的情况。这样的话，当我们的GC新生代的时候，从根对象与记录集中就行，那么这个记录怎么做到呢，采用的写入屏障（write barrier）的方法

7. 那么我们什么时候GC老年代对象的呢？当我们发现新生代的对象的年龄到了之后，要晋升为老年代对象的时候，会先检查老年代空间是否满了，满的话我们就开始老年代GC，老年代对象GC采用的就是标记清除的方法，注意这里应该是把整个堆都进行了GC
